<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EdgeProxy — fast proxy for your GitHub Pages</title>
<!-- Tailwind CDN (for quick styling) -->
<script src="https://cdn.tailwindcss.com"></script>
<style>
  /* small custom touches */
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; }
  .card { background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(245,247,250,0.9)); }
</style>
</head>
<body class="bg-gradient-to-b from-slate-50 to-slate-100 min-h-screen text-slate-800">
<main class="max-w-4xl mx-auto p-6">
  <header class="flex items-center gap-4 mb-6">
    <div class="rounded-2xl bg-gradient-to-tr from-indigo-500 to-cyan-400 p-3 text-white shadow-lg">
      <svg width="36" height="36" viewBox="0 0 24 24" fill="none"><path d="M3 12a9 9 0 1118 0 9 9 0 01-18 0zm3-1v2h6V8H9v3H6z" fill="currentColor"/></svg>
    </div>
    <div>
      <h1 class="text-2xl font-semibold">EdgeProxy</h1>
      <p class="text-sm text-slate-500">Fast Cloudflare Worker + GitHub Pages frontend — enter a URL, your token, and go.</p>
    </div>
  </header>

  <section class="card p-6 rounded-2xl shadow-md">
    <label class="block mb-2 text-sm font-medium">Cloudflare Worker URL</label>
    <input id="workerUrl" class="w-full p-3 rounded-lg border mono" placeholder="https://your-worker.example.workers.dev" />

    <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mt-4">
      <div>
        <label class="block text-sm font-medium mb-1">Method</label>
        <select id="method" class="w-full p-2 rounded-lg border">
          <option>GET</option><option>POST</option><option>PUT</option><option>PATCH</option><option>DELETE</option>
        </select>
      </div>
      <div>
        <label class="block text-sm font-medium mb-1">Target URL</label>
        <input id="targetUrl" class="w-full p-2 rounded-lg border mono" placeholder="https://api.example.com/data" />
      </div>
      <div>
        <label class="block text-sm font-medium mb-1">Token (x-proxy-token)</label>
        <input id="token" class="w-full p-2 rounded-lg border mono" placeholder="Secret token (saved locally)" />
      </div>
    </div>

    <label class="block mt-4 text-sm font-medium">Request Headers (JSON)</label>
    <textarea id="reqHeaders" class="w-full p-3 rounded-lg border mono" rows="3" placeholder='{"Accept":"application/json"}'></textarea>

    <label class="block mt-4 text-sm font-medium">Request Body (JSON or raw)</label>
    <textarea id="body" class="w-full p-3 rounded-lg border mono" rows="6" placeholder='{"example":"body"}'></textarea>

    <div class="flex gap-3 mt-4">
      <button id="send" class="px-4 py-2 rounded-lg bg-indigo-600 text-white shadow hover:opacity-95">Send</button>
      <button id="saveToken" class="px-4 py-2 rounded-lg border">Save token locally</button>
      <button id="clear" class="px-4 py-2 rounded-lg border">Clear</button>
    </div>
  </section>

  <section class="mt-6 p-4 rounded-2xl bg-white shadow-sm">
    <div class="flex justify-between items-center mb-3">
      <h2 class="text-lg font-medium">Response</h2>
      <div class="text-sm text-slate-500">Status: <span id="status">—</span></div>
    </div>

    <div class="flex gap-4">
      <div class="w-1/3">
        <div class="text-sm font-medium mb-1">Headers</div>
        <pre id="respHeaders" class="p-3 rounded-lg border h-64 overflow-auto mono text-xs"></pre>
      </div>
      <div class="w-2/3">
        <div class="text-sm font-medium mb-1">Body / Preview</div>
        <div class="p-3 rounded-lg border h-64 overflow-auto mono text-sm" id="respBody"></div>
      </div>
    </div>
    <div class="flex gap-3 mt-3">
      <a id="download" class="hidden px-3 py-2 rounded-lg border">Download</a>
      <button id="copy" class="px-3 py-2 rounded-lg border">Copy Body</button>
    </div>
  </section>

  <footer class="mt-6 text-sm text-slate-500">
    <p>Tip: store your token in GitHub Pages secrets and reference it only in local use. Do not embed your token in public repos.</p>
  </footer>
</main>

<script>
  // Small UX logic
  const workerUrlEl = document.getElementById('workerUrl');
  const methodEl = document.getElementById('method');
  const targetUrlEl = document.getElementById('targetUrl');
  const tokenEl = document.getElementById('token');
  const reqHeadersEl = document.getElementById('reqHeaders');
  const bodyEl = document.getElementById('body');

  const sendBtn = document.getElementById('send');
  const saveBtn = document.getElementById('saveToken');
  const clearBtn = document.getElementById('clear');

  const statusEl = document.getElementById('status');
  const respHeadersEl = document.getElementById('respHeaders');
  const respBodyEl = document.getElementById('respBody');
  const downloadLink = document.getElementById('download');
  const copyBtn = document.getElementById('copy');

  // Load saved token
  if (localStorage.getItem('edgeproxy_token')) tokenEl.value = localStorage.getItem('edgeproxy_token');
  if (localStorage.getItem('edgeproxy_worker')) workerUrlEl.value = localStorage.getItem('edgeproxy_worker');

  saveBtn.onclick = () => {
    localStorage.setItem('edgeproxy_token', tokenEl.value || '');
    localStorage.setItem('edgeproxy_worker', workerUrlEl.value || '');
    saveBtn.textContent = 'Saved ✓';
    setTimeout(()=> saveBtn.textContent='Save token locally', 1200);
  };

  clearBtn.onclick = () => {
    methodEl.value = 'GET';
    targetUrlEl.value = '';
    reqHeadersEl.value = '';
    bodyEl.value = '';
    statusEl.textContent = '—';
    respHeadersEl.textContent = '';
    respBodyEl.textContent = '';
    downloadLink.classList.add('hidden');
  };

  sendBtn.onclick = async () => {
    const worker = workerUrlEl.value.trim();
    if (!worker) return alert('Enter your Cloudflare Worker URL (e.g. https://my-worker.workers.dev)');
    const token = tokenEl.value.trim();
    if (!token) {
      if (!confirm('No token provided. This proxy requires x-proxy-token. Continue anyway?')) return;
    }
    const target = targetUrlEl.value.trim();
    if (!target) return alert('Enter a target URL to fetch');

    // Construct request to Worker: we pass target in ?url= to make it simple
    const url = new URL(worker);
    // send as query to ensure GET-friendly for simple tests; otherwise we use JSON body for POST etc.
    if (methodEl.value === 'GET') url.searchParams.set('url', target);

    const headers = {};
    try { Object.assign(headers, JSON.parse(reqHeadersEl.value || '{}')); } catch (e) {
      return alert('Request Headers JSON is invalid');
    }

    const init = {
      method: methodEl.value,
      headers: {
        'x-proxy-token': token,
        'Accept': headers.Accept || '*/*',
        ...headers
      }
    };

    if (!['GET','HEAD'].includes(methodEl.value) && bodyEl.value.trim()) {
      // try parse JSON body
      try {
        const b = JSON.parse(bodyEl.value);
        init.body = JSON.stringify(b);
        init.headers['Content-Type'] = 'application/json';
      } catch (e) {
        // raw body
        init.body = bodyEl.value;
        if (!init.headers['Content-Type']) init.headers['Content-Type'] = 'text/plain';
      }
    }

    statusEl.textContent = 'Loading...';
    respHeadersEl.textContent = '';
    respBodyEl.textContent = '';

    try {
      const resp = await fetch(url.toString(), init);
      statusEl.textContent = resp.status + ' ' + resp.statusText;
      // Headers
      const h = {};
      for (const pair of resp.headers.entries()) h[pair[0]] = pair[1];
      respHeadersEl.textContent = JSON.stringify(h, null, 2);

      // Body: attempt to render text / JSON; for binary, offer download
      const ct = resp.headers.get('content-type') || '';
      const blob = await resp.blob();
      const size = blob.size;
      // If it's JSON / text-like, show preview
      if (ct.includes('application/json') || ct.includes('text/') || ct.includes('application/javascript')) {
        const text = await blob.text();
        try {
          const parsed = JSON.parse(text);
          respBodyEl.textContent = JSON.stringify(parsed, null, 2);
        } catch (e) {
          respBodyEl.textContent = text;
        }
        downloadLink.classList.add('hidden');
      } else {
        // binary - offer download
        const objectUrl = URL.createObjectURL(blob);
        downloadLink.href = objectUrl;
        downloadLink.download = 'response.bin';
        downloadLink.classList.remove('hidden');
        respBodyEl.textContent = 'Binary response: ' + size + ' bytes. Use Download to save.';
      }
    } catch (err) {
      statusEl.textContent = 'Error';
      respBodyEl.textContent = 'Network or proxy error: ' + err.message;
    }
  };

  copyBtn.onclick = async () => {
    const txt = respBodyEl.textContent || '';
    try {
      await navigator.clipboard.writeText(txt);
      copyBtn.textContent = 'Copied ✓';
      setTimeout(()=> copyBtn.textContent='Copy Body',1200);
    } catch(e) {
      alert('Could not copy: ' + e.message);
    }
  };
</script>
</body>
</html>
